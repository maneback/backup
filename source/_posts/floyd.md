---
title: 图论算法(二) 最短路径Floyd算法
date: 2018-03-31 15:10:37
tags:
- 图论
- 最短路径
categories:
- Algorithm
description: Floyd 算法是解决任意两点之间的最短路径的一种算法，可以正确处理有向图或者负权图
---

Floyd 算法是解决任意两点之间的最短路径的一种算法，可以正确处理有向图或者负权图（但是不能有负权回路）


图的邻接矩阵`G[i][j]`

如果要两个顶点a和b之间的距离变短，就只能引入第三个顶点k，并通过顶点k中转得到路径`a->k->b`，才能缩短a到b的距离。
有时可能经过两个，三个顶点会变得更短，那么将这个问题一般化之后：
****
1. 当任意两点之间不允许通过第三个点时，最短路径矩阵P就初始为图的邻接矩阵G。
2. 如果此时只允许通过编号为1的顶点，求任意两个顶点之间的最短路径：（其实顶点1只是一个一般化的顶点，只是为了在后面的迭代循环中容易表示，所以选择1为第一个顶点）
  只需要判断`P[i][j]` 与`P[i][1]+P[1][j]`的大小即可。
  代码如下：

```cpp
//对于任意两点经过1的距离都进行比较
for(int i = 1; i <= n; i++){
	for(int j = 1; j <= n; j++){
		if(P[i][1]+P[1][j] < P[i][j])
			P[i][j] = P[i][1]+P[1][j];
	}
	
}
```

3. 那么，还有可能经过1和2两个顶点之后，比只允许经过顶点1的路径还要短，则在经过1的基础上，在用经过2来更新矩阵P


```cpp
//顶点1
for(int i = 1; i <= n; i++){
	for(int j = 1; j <= n; j++){
		if(P[i][1]+P[1][j] < P[i][j])
			P[i][j] = P[i][1]+P[1][j];
	}
}
//顶点2 
for(int i = 1; i <= n; i++){
	for(int j = 1; j <= n; j++){
		if(P[i][2]+P[2][j] < P[i][j])
			P[i][j] = P[i][2]+P[2][j];
	}
	
}
```

4. 更一般化，我们允许每一对顶点都可以经过任何顶点，即再嵌套一层循环
 - k代表允许中间经过的顶点。


```cpp
for(int k = 1; k <= n; k++){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(P[i][k]+P[k][j] < P[i][j])
				P[i][j] = P[i][k]+P[k][j];
		}
	}	
}
```

##### 关于不能将循环变量k放在最里面的解释：

  如果将k循环放在最里面，则过早的把i到j的最短路径确定下来了，之后存在更短的路径之后，矩阵P也不会再继续更新了。

关于两个顶点之间不存在直接通路的情况，可以用一个不会达到的权值表示无穷大的距离。在比较之前先判断i到k之间和k到j之间是否存在通路。
更新为：

```cpp
#define NOWAY 10000 //最长路径不会超过这个
for(int k = 1; k <= n; k++){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(P[i][k] < NOWAY && P[k][j] < NOWAY &&P[i][k]+P[k][j] < P[i][j])
				P[i][j] = P[i][k]+P[k][j];
		}
	}	
}
```